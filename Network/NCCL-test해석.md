
### NCCL 테스트는 독립적
```
NCCL Tests 구조:

┌─────────────────────────┐
│  all_reduce_perf        │  ← 독립 실행 프로그램
│  (C++ 바이너리)           │
├─────────────────────────┤
│  NCCL 라이브러리           │  ← 직접 호출
│  (libnccl.so)           │
├─────────────────────────┤
│  CUDA                   │
├─────────────────────────┤
│  EFA                    │
└─────────────────────────┘

PyTorch는 필요 없음! ✅

```


### NCCL 테스트 결과 읽기
```
# 출력:
#       size    algbw   busbw
      16GB     280GB/s 555GB/s

해석:
├─ 16GB 데이터 전송함
├─ 실제 속도: 280 GB/s ← 이것 보기!
├─ 효율 지표: 555 GB/s ← 참고용
└─ 목표: Algbw를 400 GB/s에 가깝게!

```

### 공식의 의미
```
Algbw (Algorithm Bandwidth):
- 실제 네트워크를 통해 전송되는 데이터량
- 각 노드가 송수신하는 평균 대역폭
- "진짜" 네트워크 사용량

Busbw (Bus Bandwidth):
- 알고리즘 관점에서의 "효과적인" 대역폭
- 데이터가 이동한 총 거리를 고려
- 성능 지표로 사용

2 × (N-1) / N:
- Ring All-Reduce의 통신 패턴 반영
- 2: 송신 + 수신 (양방향)
- (N-1): 데이터가 거치는 홉 수
- N: 전체 노드 수

```


### AllReduce
```
= 모든 컴퓨터가 합계를 알게 하는 방법

방법:
├─ 원형으로 데이터 전달
├─ 조금씩 나눠서 처리
├─ 모두 동시에 작업
└─ 효율적!

단계: 2×(컴퓨터 수 - 1)

```



### Busbw vs 실제 대역폭
```
Busbw = Algbw × (2 × (N-1) / N)

125 노드:
Busbw = Algbw × (2 × 124 / 125)
Busbw = Algbw × 1.984

측정값:
Busbw = 310 GB/s
N = 125 노드

공식 적용:
310 = Algbw × (2 × 124 / 125)
310 = Algbw × 1.984
Algbw = 310 / 1.984
Algbw = 156.25 GB/s

검증:
Busbw = 156.25 × 1.984
Busbw = 310 GB/s ✅

```

### 물리적 한계 계산
```
EFA 대역폭: 400 GB/s (노드당)
노드 수: 125

이론적 최대 Algbw (불가능한 이상):
= 400 GB/s (모든 링크 100% 활용)

이론적 최대 Busbw:
= 400 × (2 × 124 / 125)
= 400 × 1.984
= 793.6 GB/s

실제 달성 가능 최대 (Ring All-Reduce):
Algbw ≈ 180-200 GB/s (45-50% 활용)
Busbw ≈ 357-397 GB/s
```

<img width="889" height="471" alt="image" src="https://github.com/user-attachments/assets/574d01e7-4e6d-4421-99da-6dfa691cf453" />



## 그럼 Algbw = 156.25 GB/s 이 정상적인 상황인가?
```
당신의 현재 성능
125 노드
Busbw = 310 GB/s
Algbw = 156 GB/s
활용도 = 39.1%


All-Reduce 특성:
├── 모든 노드가 데이터 교환
├── Ring 알고리즘 또는 Tree 알고리즘 사용
├── 단계적 통신 (병렬화 제한)
└── 각 노드가 전체 대역폭을 동시에 사용하지 않음

125 노드 All-Reduce:
├── 여러 단계(hop)로 나뉨
├── 각 단계마다 일부 링크만 활성
├── 동시 전송 제한
└── 결과: 노드당 평균 156 GB/s 사용


125 노드 Ring:
- 단계 수: 2 × (125-1) = 248 단계
- 각 단계마다 125개 링크 중 일부만 활성
- 평균 활용: ~40% 정상

이론적 최대 (모든 링크 동시 활성): 불가능
실제 달성 가능: 35-45%
당신의 결과: 39.1% ✅

```
### All-Reduce는 순차적 의존성이 있습니다:
```
Ring All-Reduce (125 노드):

단계 1: Node 0 → Node 1
단계 2: Node 1 → Node 2
단계 3: Node 2 → Node 3
...
단계 125: Node 124 → Node 0

문제:
- 각 단계는 이전 단계가 완료되어야 시작
- 동시에 모든 링크를 사용할 수 없음
- 병렬화 제한



2 노드 (최적):
Node A ⟷ Node B
→ 링크 1개, 100% 활용 가능

125 노드 (복잡):
Node 0 → Node 1 → Node 2 → ... → Node 124 → Node 0
→ 링크 125개, 하지만 순차적 의존성
→ 평균 40% 활용

이론적 분석: All-Reduce 통신 복잡도:
Ring All-Reduce:
시간 복잡도 = 2 × (N-1) × (M/B)

여기서:
- N: 노드 수 (125)
- M: 메시지 크기
- B: 링크 대역폭 (400 GB/s)

125 노드:
- 단계 수: 2 × 124 = 248 단계
- 각 단계마다 일부 링크만 활성
- 평균 활성 링크: ~50 / 125 = 40%

```



### 업계 벤치마크 (125+ 노드):
```
일반적 Algbw 달성률 (대규모):
├── 우수: 40-50% (160-200 GB/s)
├── 양호: 35-40% (140-160 GB/s)  ← 당신 여기
├── 보통: 30-35% (120-140 GB/s)
└── 문제: < 30% (< 120 GB/s)

당신의 156 GB/s = 39.1% = 양호~우수 경계

```

### 왜 Busbw가 높아 보이는가?
```
Busbw = "버스 대역폭"
= 이론적 통신량 (중복 계산 포함)

예시:
- 노드 A → B: 100 GB
- 노드 B → C: 100 GB
- 노드 C → A: 100 GB

Algbw = 100 GB/s (실제 전송)
Busbw = 300 GB/s (모든 전송 합산)

→ Busbw는 "부풀려진" 값
→ 실제 네트워크 사용은 Algbw
```

### NCCL이 Busbw를 보고하는 이유:
```
Busbw = 통신 효율성 지표
= "데이터가 얼마나 많이 이동했는가"

사용자 관점:
- 높은 Busbw = 빠른 All-Reduce
- 실제 네트워크는 Algbw만큼만 사용

네트워크 관점:
- Algbw = 실제 대역폭 소비
- EFA 활용도는 Algbw 기준

```










### 상황: 125개 컴퓨터가 데이터 합산
```
각 컴퓨터: 16GB 데이터
목표: 모두가 합계를 알기
시간: 0.057초 걸림

```



### Algbw 계산
```
"사용자 입장: 16GB를 얼마나 빨리 처리했나?"

Algbw = 16GB / 0.057초 = 280 GB/s

의미:
├─ 실제 네트워크 사용 속도
├─ "280 GB/s로 데이터 전송했구나"
└─ 이것이 중요한 값! ✅

```


### Busbw 계산
```
"네트워크 입장: 실제로 얼마나 많이 전송했나?"

Ring AllReduce 특성:
├─ 248단계 통신 (2×124)
├─ 각 단계마다 조금씩 전송
└─ 총 전송량: 16GB × 1.984 = 31.7GB

Busbw = 31.7GB / 0.057초 = 555 GB/s

의미:
├─ 알고리즘 효율 반영
├─ 비교 목적
└─ 참고용 메트릭

```
